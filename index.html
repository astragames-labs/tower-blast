<!DOCTYPE html>
<html lang="en">

	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Tower Blast - Astragames Labs</title>
		<style>
			body {
				margin: 0;
				display: flex;
				justify-content: center;
				align-items: center;
				min-height: 100vh;
				background: linear-gradient(to bottom, #0f0c29, #302b63);
				font-family: 'Orbitron', 'Segoe UI', Arial, sans-serif;
				overflow: auto;
			}

			#gameArea {
				display: flex;
				flex-direction: column;
				align-items: center;
				padding: 25px;
				background: #1a1a3a;
				border-radius: 15px;
				box-shadow: 0 0 40px rgba(0, 0, 0, 0.8);
			}

			#gameCanvas {
				border: 4px solid #0a0a1a;
				background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAJElEQVQYV2NkIAIwEqG+YSZi/0O8xFjNTAxhYWFhYWFhYWFhAHY0B7k1cY/2AAAAAElFTkSuQmCC') repeat;
				border-radius: 10px;
			}

			#titleScreen {
				position: absolute;
				top: 0;
				left: 0;
				width: 700px;
				height: 500px;
				background: linear-gradient(to bottom, rgba(0, 0, 60, 0.95), rgba(0, 0, 100, 0.95));
				color: #fff;
				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
				text-align: center;
				transition: opacity 0.8s ease;
				border-radius: 10px;
				z-index: 10;
			}

			#titleScreen h1 {
				font-size: 60px;
				margin: 20px 0;
				text-shadow: 0 0 10px #00ffcc, 0 0 20px #00ffcc;
				animation: glow 1.5s infinite alternate;
			}

			#titleScreen p {
				font-size: 24px;
				margin: 10px 0;
				color: #00ffcc;
			}

			@keyframes glow {
				from {
					text-shadow: 0 0 10px #00ffcc, 0 0 20px #00ffcc;
				}

				to {
					text-shadow: 0 0 20px #00ffcc, 0 0 30px #00ffcc;
				}
			}

			#ui {
				margin-top: 25px;
				background: linear-gradient(to bottom, rgba(0, 0, 60, 0.9), rgba(0, 0, 100, 0.9));
				color: #fff;
				padding: 25px;
				border-radius: 12px;
				font-size: 16px;
				backdrop-filter: blur(10px);
				box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
				width: 660px;
				display: flex;
				justify-content: space-between;
				align-items: flex-start;
				border: 1px solid #00ffcc;
			}

			.stats-panel {
				display: flex;
				flex-direction: column;
				gap: 8px;
				width: 200px;
			}

			.button-panel {
				display: flex;
				flex-wrap: wrap;
				gap: 12px;
				max-width: 400px;
			}

			.tower-btn,
			.menu-btn,
			.map-btn {
				padding: 12px 22px;
				cursor: pointer;
				background: linear-gradient(to bottom, #00ffcc, #00b3a6);
				border: none;
				color: #1a1a3a;
				border-radius: 8px;
				font-size: 14px;
				font-weight: bold;
				transition: transform 0.2s, background 0.2s, box-shadow 0.2s;
				position: relative;
				box-shadow: 0 3px 8px rgba(0, 255, 204, 0.4);
			}

			.tower-btn:hover:not(.disabled),
			.menu-btn:hover:not(.disabled),
			.map-btn:hover:not(.disabled) {
				transform: translateY(-3px);
				background: linear-gradient(to bottom, #00e6b8, #009688);
				box-shadow: 0 6px 12px rgba(0, 255, 204, 0.6);
			}

			.start-wave-btn {
				background: linear-gradient(to bottom, #ffeb3b, #fbc02d);
			}

			.start-wave-btn:hover:not(.disabled) {
				background: linear-gradient(to bottom, #ffee58, #ffca28);
			}

			.cancel-btn {
				background: linear-gradient(to bottom, #ff5555, #cc3333);
			}

			.cancel-btn:hover:not(.disabled) {
				background: linear-gradient(to bottom, #ff7777, #dd4444);
			}

			.disabled {
				background: linear-gradient(to bottom, #555, #444);
				color: #888;
				cursor: not-allowed;
				transform: none;
				box-shadow: none;
			}

			.tooltip {
				visibility: hidden;
				position: absolute;
				bottom: 100%;
				left: 50%;
				transform: translateX(-50%);
				background: #0a0a2a;
				color: #00ffcc;
				padding: 8px 12px;
				border-radius: 6px;
				font-size: 12px;
				white-space: nowrap;
				z-index: 10;
				border: 1px solid #00ffcc;
				transition: opacity 0.2s;
			}

			.tower-btn:hover .tooltip,
			.menu-btn:hover .tooltip,
			.map-btn:hover .tooltip {
				visibility: visible;
				opacity: 1;
			}

			#waveProgress {
				width: 180px;
				height: 14px;
				background: #333;
				border-radius: 6px;
				overflow: hidden;
				border: 1px solid #00ffcc;
			}

			#waveProgressBar {
				height: 100%;
				background: linear-gradient(to right, #00ffcc, #66BB6A);
				transition: width 0.4s ease;
			}

			#waveTimer {
				font-size: 14px;
				margin-top: 8px;
				text-align: left;
				color: #00ffcc;
			}

			.tower-popup {
				position: absolute;
				background: linear-gradient(to bottom, rgba(0, 0, 60, 0.9), rgba(0, 0, 100, 0.9));
				color: #fff;
				padding: 15px;
				border-radius: 8px;
				font-size: 14px;
				backdrop-filter: blur(10px);
				box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
				border: 1px solid #00ffcc;
				z-index: 5;
				display: none;
				width: 200px;
			}

			.tower-popup button {
				margin: 5px 0;
				width: 100%;
				padding: 8px;
				cursor: pointer;
				border: none;
				border-radius: 6px;
				font-weight: bold;
				transition: transform 0.2s, background 0.2s;
			}

			.tower-popup .upgrade-btn {
				background: linear-gradient(to bottom, #ff4081, #d81b60);
			}

			.tower-popup .upgrade-btn:hover:not(.disabled) {
				background: linear-gradient(to bottom, #f50057, #c2185b);
				transform: translateY(-2px);
			}

			.tower-popup .sell-btn {
				background: linear-gradient(to bottom, #ff5555, #cc3333);
			}

			.tower-popup .sell-btn:hover:not(.disabled) {
				background: linear-gradient(to bottom, #ff7777, #dd4444);
				transform: translateY(-2px);
			}

			.tower-popup .target-btn {
				background: linear-gradient(to bottom, #4fc3f7, #0288d1);
			}

			.tower-popup .target-btn:hover:not(.disabled) {
				background: linear-gradient(to bottom, #81d4fa, #0277bd);
				transform: translateY(-2px);
			}

			.tower-popup .target-btn.active {
				background: linear-gradient(to bottom, #ffeb3b, #fbc02d);
				transform: scale(1.05);
			}

			@keyframes backgroundParticles {
				0% {
					transform: translateY(0);
					opacity: 0.5;
				}

				100% {
					transform: translateY(-600px);
					opacity: 0;
				}
			}
		</style>
	</head>

	<body>
		<div id="gameArea">
			<canvas id="gameCanvas" width="700" height="500"></canvas>
			<div id="titleScreen">
				<h1>Tower Blast - Astragames Labs</h1>
				<p>Choose Your Battleground</p>
				<button class="map-btn" id="map1Btn">Nebula Pass <span class="tooltip">Easy: Open paths, 150
						money</span></button>
				<button class="map-btn" id="map2Btn">Asteroid Belt <span class="tooltip">Medium: Tight turns, 100
						money</span></button>
				<button class="map-btn" id="map3Btn">Star Forge <span class="tooltip">Medium: Split paths, 100
						money</span></button>
				<button class="map-btn" id="map4Btn">Black Hole Rim <span class="tooltip">Hard: Long route, 75
						money</span></button>
				<button class="map-btn" id="map5Btn">Cosmic Rift <span class="tooltip">Hard: Complex grid, 50
						money</span></button>
			</div>
			<div id="ui" style="display: none;">
				<div class="stats-panel">
					<div>Score: <span id="score">0</span></div>
					<div>Money: $<span id="money">100</span></div>
					<div>Health: <span id="health">100</span></div>
					<div>Wave: <span id="wave">1</span></div>
					<div id="waveProgress">
						<div id="waveProgressBar" style="width: 0%;"></div>
					</div>
					<div id="waveTimer">Next Wave: --</div>
				</div>
				<div class="button-panel">
					<button class="tower-btn" id="basicTowerBtn">Basic Tower ($50) <span class="tooltip">Balanced: 25
							damage, 100 range</span></button>
					<button class="tower-btn" id="fastTowerBtn">Fast Tower ($75) <span class="tooltip">Rapid: 15 damage,
							80 range</span></button>
					<button class="tower-btn" id="heavyTowerBtn">Heavy Tower ($100) <span class="tooltip">Powerful: 50
							damage, 120 range</span></button>
					<button class="tower-btn start-wave-btn" id="startWaveBtn">Start Wave <span class="tooltip">Begin
							the next wave</span></button>
					<button class="tower-btn cancel-btn" id="cancelBtn">Cancel <span class="tooltip">Cancel tower
							placement</span></button>
					<button class="tower-btn menu-btn" id="pauseBtn">Pause <span class="tooltip">Pause or resume
							game</span></button>
					<button class="tower-btn menu-btn" id="soundBtn">Sound: On <span class="tooltip">Toggle sound
							effects</span></button>
					<button class="tower-btn menu-btn" id="musicBtn">Music: Off <span class="tooltip">Toggle background
							music</span></button>
				</div>
			</div>
			<div id="towerPopup" class="tower-popup">
				<div id="popupInfo">Tower Info</div>
				<button class="upgrade-btn" id="popupUpgradeBtn">Upgrade</button>
				<button class="sell-btn" id="popupSellBtn">Sell</button>
				<button class="target-btn" id="targetClosestBtn">Target: Closest</button>
				<button class="target-btn" id="targetFarthestBtn">Target: Farthest</button>
				<button class="target-btn" id="targetMostHealthBtn">Target: Most Health</button>
				<button class="target-btn" id="targetLeastHealthBtn">Target: Least Health</button>
			</div>
		</div>
		<script>
			const canvas = document.getElementById('gameCanvas');
			const ctx = canvas.getContext('2d');
			const scoreDisplay = document.getElementById('score');
			const moneyDisplay = document.getElementById('money');
			const healthDisplay = document.getElementById('health');
			const waveDisplay = document.getElementById('wave');
			const basicTowerBtn = document.getElementById('basicTowerBtn');
			const fastTowerBtn = document.getElementById('fastTowerBtn');
			const heavyTowerBtn = document.getElementById('heavyTowerBtn');
			const pauseBtn = document.getElementById('pauseBtn');
			const soundBtn = document.getElementById('soundBtn');
			const musicBtn = document.getElementById('musicBtn');
			const startWaveBtn = document.getElementById('startWaveBtn');
			const cancelBtn = document.getElementById('cancelBtn');
			const titleScreen = document.getElementById('titleScreen');
			const map1Btn = document.getElementById('map1Btn');
			const map2Btn = document.getElementById('map2Btn');
			const map3Btn = document.getElementById('map3Btn');
			const map4Btn = document.getElementById('map4Btn');
			const map5Btn = document.getElementById('map5Btn');
			const waveProgressBar = document.getElementById('waveProgressBar');
			const waveTimerDisplay = document.getElementById('waveTimer');
			const towerPopup = document.getElementById('towerPopup');
			const popupInfo = document.getElementById('popupInfo');
			const popupUpgradeBtn = document.getElementById('popupUpgradeBtn');
			const popupSellBtn = document.getElementById('popupSellBtn');
			const targetClosestBtn = document.getElementById('targetClosestBtn');
			const targetFarthestBtn = document.getElementById('targetFarthestBtn');
			const targetMostHealthBtn = document.getElementById('targetMostHealthBtn');
			const targetLeastHealthBtn = document.getElementById('targetLeastHealthBtn');

			// Game state
			let score = 0;
			let highScore = localStorage.getItem('towerDefenseHighScore') || 0;
			let money = 100;
			let health = 100;
			let wave = 1;
			let enemies = [];
			let towers = [];
			let projectiles = [];
			let particles = [];
			let damageTexts = [];
			let placingTower = null;
			let selectedTower = null;
			let gameOver = false;
			let isPaused = false;
			let soundEnabled = true;
			let musicEnabled = false;
			let gameStarted = false;
			let waveStarted = false;
			let waveCountdown = 10;
			let scoreMultiplier = 1;
			let consecutiveKills = 0;
			let powerUp = null;
			let powerUpTimer = 0;
			let animationFrameId;
			let currentMap = null;

			// Map definitions with grid-aligned square paths
			const maps = {
				map1: {
					name: 'Nebula Pass',
					difficulty: { health: 0.7, speed: 0.8, enemies: 0.7, money: 150 },
					path: [
						{ x: 0, y: 105 },    // Start left
						{ x: 175, y: 105 },  // Right 5 tiles
						{ x: 175, y: 245 },  // Down 4 tiles
						{ x: 525, y: 245 },  // Right 10 tiles
						{ x: 525, y: 105 },  // Up 4 tiles
						{ x: 700, y: 105 }   // Right to exit
					]
				},
				map2: {
					name: 'Asteroid Belt',
					difficulty: { health: 1, speed: 1, enemies: 1, money: 100 },
					path: [
						{ x: 0, y: 105 },    // Start left
						{ x: 140, y: 105 },  // Right 4 tiles
						{ x: 140, y: 315 },  // Down 6 tiles
						{ x: 350, y: 315 },  // Right 6 tiles
						{ x: 350, y: 175 },  // Up 4 tiles
						{ x: 560, y: 175 },  // Right 6 tiles
						{ x: 560, y: 385 },  // Down 6 tiles
						{ x: 700, y: 385 }   // Right to exit
					]
				},
				map3: {
					name: 'Star Forge',
					difficulty: { health: 1, speed: 1, enemies: 1, money: 100 },
					path: [
						{ x: 0, y: 175 },    // Start left
						{ x: 210, y: 175 },  // Right 6 tiles
						{ x: 210, y: 105 },  // Up 2 tiles
						{ x: 350, y: 105 },  // Right 4 tiles
						{ x: 350, y: 245 },  // Down 4 tiles
						{ x: 210, y: 245 },  // Left 4 tiles
						{ x: 210, y: 385 },  // Down 4 tiles
						{ x: 700, y: 385 }   // Right to exit
					]
				},
				map4: {
					name: 'Black Hole Rim',
					difficulty: { health: 1.3, speed: 1.2, enemies: 1.3, money: 75 },
					path: [
						{ x: 0, y: 105 },    // Start left
						{ x: 140, y: 105 },  // Right 4 tiles
						{ x: 140, y: 385 },  // Down 8 tiles
						{ x: 350, y: 385 },  // Right 6 tiles
						{ x: 350, y: 175 },  // Up 6 tiles
						{ x: 560, y: 175 },  // Right 6 tiles
						{ x: 560, y: 455 },  // Down 8 tiles
						{ x: 700, y: 455 }   // Right to exit
					]
				},
				map5: {
					name: 'Cosmic Rift',
					difficulty: { health: 1.3, speed: 1.2, enemies: 1.3, money: 50 },
					path: [
						{ x: 0, y: 105 },    // Start left
						{ x: 105, y: 105 },  // Right 3 tiles
						{ x: 105, y: 245 },  // Down 4 tiles
						{ x: 245, y: 245 },  // Right 4 tiles
						{ x: 245, y: 105 },  // Up 4 tiles
						{ x: 455, y: 105 },  // Right 6 tiles
						{ x: 455, y: 315 },  // Down 6 tiles
						{ x: 595, y: 315 },  // Right 4 tiles
						{ x: 595, y: 175 },  // Up 4 tiles
						{ x: 700, y: 175 }   // Right to exit
					]
				}
			};

			// Sound effects
			const shootSound = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA');
			const explosionSound = new Audio('data:audio/wav;base64,UklGRlAAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA');
			const powerUpSound = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA');
			const backgroundMusic = new Audio('data:audio/mp3;base64,/+MYxAAAAANIAUAAAAA==');
			backgroundMusic.loop = true;

			// Enemy types
			const enemyTypes = [
				{ health: 100, speed: 2, color: '#e91e63', size: 12, reward: 20, ability: null },
				{ health: 50, speed: 3, color: '#9c27b0', size: 10, reward: 15, ability: 'fast' },
				{ health: 200, speed: 1, color: '#8d6e63', size: 14, reward: 30, ability: 'tank' },
				{ health: 150, speed: 1.5, color: '#26a69a', size: 11, reward: 25, ability: 'regen' }
			];

			// Tower types
			const towerTypes = {
				basic: { range: 100, fireRate: 60, damage: 25, color: '#2196F3', size: 15, cost: 50 },
				fast: { range: 80, fireRate: 30, damage: 15, color: '#4CAF50', size: 12, cost: 75 },
				heavy: { range: 120, fireRate: 90, damage: 50, color: '#FF9800', size: 18, cost: 100 }
			};

			// Grid settings
			const GRID_SIZE = 35;

			// Particle class for animations
			class Particle {
				constructor(x, y, color, type = 'normal') {
					this.x = x;
					this.y = y;
					this.color = color;
					this.size = type === 'background' ? Math.random() * 3 + 1 : Math.random() * 5 + 3;
					this.vx = type === 'background' ? 0 : (Math.random() - 0.5) * 6;
					this.vy = type === 'background' ? -(Math.random() * 0.5 + 0.2) : (Math.random() - 0.5) * 6;
					this.life = type === 'background' ? 200 : 25;
				}
				update() {
					this.x += this.vx;
					this.y += this.vy;
					this.life--;
					if (this.life <= 0) {
						if (this.vy < 0) {
							this.y = canvas.height;
							this.life = 200;
						} else {
							particles.splice(particles.indexOf(this), 1);
						}
					}
					this.size *= 0.93;
				}
				draw() {
					ctx.globalAlpha = this.life / (this.vy < 0 ? 200 : 25);
					ctx.fillStyle = this.color;
					ctx.beginPath();
					ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
					ctx.fill();
					ctx.globalAlpha = 1;
				}
			}

			// Damage Text class
			class DamageText {
				constructor(x, y, text, color, isCrit = false) {
					this.x = x;
					this.y = y;
					this.text = text;
					this.color = color;
					this.life = 40;
					this.vy = -1.5;
					this.scale = isCrit ? 1.5 : 1;
				}
				update() {
					this.y += this.vy;
					this.life--;
					this.scale = Math.max(1, this.scale * 0.98);
					if (this.life <= 0) {
						damageTexts.splice(damageTexts.indexOf(this), 1);
					}
				}
				draw() {
					ctx.globalAlpha = this.life / 40;
					ctx.fillStyle = this.color;
					ctx.font = `${16 * this.scale}px Orbitron`;
					ctx.fillText(this.text, this.x, this.y);
					ctx.globalAlpha = 1;
				}
			}

			// Enemy class
			class Enemy {
				constructor(type = 0) {
					this.x = currentMap.path[0].x - 30;
					this.y = currentMap.path[0].y;
					this.pathIndex = 0;
					this.type = enemyTypes[type];
					this.health = this.type.health * currentMap.difficulty.health;
					this.speed = this.type.speed * currentMap.difficulty.speed;
					this.maxHealth = this.health;
					this.spawnTimer = 20;
					this.angle = 0;
					this.regenTimer = 0;
				}
				update() {
					if (this.spawnTimer > 0) {
						this.spawnTimer--;
						return;
					}
					if (this.type.ability === 'regen') {
						this.regenTimer++;
						if (this.regenTimer % 60 === 0 && this.health < this.maxHealth) {
							this.health = Math.min(this.maxHealth, this.health + 5);
						}
					}
					if (this.pathIndex < currentMap.path.length - 1) {
						const target = currentMap.path[this.pathIndex + 1];
						const dx = target.x - this.x;
						const dy = target.y - this.y;
						const distance = Math.sqrt(dx * dx + dy * dy);
						this.angle = Math.atan2(dy, dx);
						if (distance < this.speed) {
							this.pathIndex++;
							this.x = target.x;
							this.y = target.y;
						} else {
							this.x += (dx / distance) * this.speed;
							this.y += (dy / distance) * this.speed;
						}
					} else {
						enemies.splice(enemies.indexOf(this), 1);
						health -= 10;
						updateUI();
						if (health <= 0) gameOver = true;
					}
				}
				draw() {
					ctx.save();
					ctx.translate(this.x, this.y);
					ctx.rotate(this.angle + Math.PI / 2);
					ctx.globalAlpha = this.spawnTimer > 0 ? this.spawnTimer / 20 : 1;
					ctx.fillStyle = this.type.color;
					ctx.beginPath();
					if (this.type.color === '#e91e63') {
						ctx.moveTo(0, -this.type.size * 1.2);
						ctx.lineTo(this.type.size, this.type.size);
						ctx.lineTo(-this.type.size, this.type.size);
						ctx.closePath();
						ctx.fill();
						ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
						ctx.lineWidth = 2;
						ctx.stroke();
					} else if (this.type.color === '#9c27b0') {
						const pulse = Math.sin(Date.now() / 200) * 2;
						ctx.rect(-this.type.size - pulse, -this.type.size - pulse, (this.type.size + pulse) * 2, (this.type.size + pulse) * 2);
						ctx.fill();
						ctx.strokeStyle = '#fff';
						ctx.lineWidth = 1;
						ctx.stroke();
					} else if (this.type.color === '#8d6e63') {
						ctx.arc(0, 0, this.type.size, 0, Math.PI * 2);
						ctx.fill();
						ctx.fillStyle = 'darkgray';
						ctx.beginPath();
						ctx.arc(0, 0, this.type.size * 0.6, 0, Math.PI * 2);
						ctx.fill();
						ctx.strokeStyle = '#fff';
						ctx.lineWidth = 2;
						ctx.stroke();
					} else {
						const sides = 6;
						ctx.beginPath();
						for (let i = 0; i < sides; i++) {
							const angle = (Math.PI * 2 / sides) * i;
							ctx.lineTo(Math.cos(angle) * this.type.size, Math.sin(angle) * this.type.size);
						}
						ctx.closePath();
						ctx.fill();
						ctx.strokeStyle = '#00ffcc';
						ctx.lineWidth = 1;
						ctx.stroke();
					}
					ctx.restore();
					ctx.globalAlpha = 1;
					ctx.fillStyle = '#4CAF50';
					ctx.fillRect(this.x - 15, this.y - 25, (this.health / this.maxHealth) * 30, 5);
					ctx.strokeStyle = '#333';
					ctx.strokeRect(this.x - 15, this.y - 25, 30, 5);
					if (this.type.ability === 'regen' && this.regenTimer % 60 < 30) {
						ctx.fillStyle = '#00ffcc';
						ctx.font = '12px Orbitron';
						ctx.fillText('+', this.x + 20, this.y - 20);
					}
				}
			}

			// Tower class
			class Tower {
				constructor(x, y, type = 'basic') {
					this.x = x;
					this.y = y;
					this.type = type;
					this.baseCost = towerTypes[type].cost;
					this.range = towerTypes[type].range;
					this.fireRate = towerTypes[type].fireRate;
					this.damage = towerTypes[type].damage;
					this.level = 1;
					this.timer = 0;
					this.firing = 0;
					this.angle = 0;
					this.targeting = 'closest'; // Default targeting mode
				}
				getUpgradeCost() {
					return Math.round(this.baseCost * (1 + this.level * 0.5));
				}
				getSellValue() {
					const totalCost = this.baseCost + (this.level > 1 ? this.baseCost * (1 + (this.level - 1) * 0.5) : 0);
					return Math.round(totalCost * 0.5);
				}
				upgrade() {
					if (this.level < 3 && money >= this.getUpgradeCost()) {
						this.level++;
						this.range += 20;
						this.damage += 10;
						this.fireRate = Math.max(15, this.fireRate - 10);
						money -= this.getUpgradeCost();
						updateUI();
						if (selectedTower === this) updatePopup();
					}
				}
				sell() {
					money += this.getSellValue();
					towers.splice(towers.indexOf(this), 1);
					selectedTower = null;
					towerPopup.style.display = 'none';
					updateUI();
				}
				setTargeting(mode = 'closest') {
					this.targeting = mode;
					if (selectedTower === this) updatePopup();
				}
				update() {
					this.firing = Math.max(0, this.firing - 1);
					this.timer++;
					if (this.timer >= this.fireRate) {
						let targetEnemy = null;
						let bestValue = this.targeting === 'farthest' ? -Infinity : Infinity;
						let maxHealth = -Infinity;
						let minHealth = Infinity;
						for (let enemy of enemies) {
							if (enemy.spawnTimer > 0) continue;
							const distance = Math.hypot(this.x - enemy.x, this.y - enemy.y);
							if (distance >= this.range) continue;
							if (this.targeting === 'closest' && distance < bestValue) {
								targetEnemy = enemy;
								bestValue = distance;
							} else if (this.targeting === 'farthest' && distance > bestValue) {
								targetEnemy = enemy;
								bestValue = distance;
							} else if (this.targeting === 'mostHealth' && enemy.health > maxHealth) {
								targetEnemy = enemy;
								maxHealth = enemy.health;
							} else if (this.targeting === 'leastHealth' && enemy.health < minHealth) {
								targetEnemy = enemy;
								minHealth = enemy.health;
							}
						}
						if (targetEnemy) {
							this.angle = Math.atan2(targetEnemy.y - this.y, targetEnemy.x - this.x);
							const rand = Math.random();
							let damage = this.damage * (powerUp === 'damage' ? 1.5 : 1);
							let text = Math.round(damage).toString();
							let color = '#fff';
							if (rand < 0.1) {
								damage = 0;
								text = 'Miss!';
								color = '#ff4444';
							} else if (rand < 0.35) {
								damage *= 1.5;
								text = `${Math.round(damage)} Crit!`;
								color = '#ffeb3b';
							}
							if (damage > 0) {
								targetEnemy.health -= damage;
								damageTexts.push(new DamageText(targetEnemy.x, targetEnemy.y - 10, text, color, rand < 0.35));
								if (targetEnemy.health <= 0) {
									for (let i = 0; i < 12; i++) {
										particles.push(new Particle(targetEnemy.x, targetEnemy.y, targetEnemy.type.color));
									}
									enemies.splice(enemies.indexOf(targetEnemy), 1);
									score += 10 * scoreMultiplier;
									money += targetEnemy.type.reward;
									consecutiveKills++;
									if (consecutiveKills >= 5) scoreMultiplier = Math.min(3, scoreMultiplier + 0.5);
									if (Math.random() < 0.1 && !powerUp) {
										powerUp = Math.random() < 0.5 ? 'damage' : 'speed';
										powerUpTimer = 600;
										if (soundEnabled) powerUpSound.play();
									}
									if (soundEnabled) explosionSound.play();
								}
							} else {
								damageTexts.push(new DamageText(targetEnemy.x, targetEnemy.y - 10, text, color));
							}
							projectiles.push(new Projectile(this.x, this.y, targetEnemy, damage, towerTypes[this.type].color));
							this.timer = 0;
							this.firing = 15;
							if (soundEnabled) shootSound.play();
						}
					}
				}
				draw() {
					ctx.save();
					ctx.translate(this.x, this.y);
					ctx.rotate(this.angle + Math.PI / 2);
					ctx.fillStyle = towerTypes[this.type].color;
					ctx.beginPath();
					if (towerTypes[this.type].color === '#2196F3') {
						ctx.rect(-towerTypes[this.type].size, -towerTypes[this.type].size, towerTypes[this.type].size * 2, towerTypes[this.type].size * 2);
						ctx.fill();
						ctx.fillStyle = '#555';
						ctx.fillRect(-5, -towerTypes[this.type].size - 10, 10, 15);
					} else if (towerTypes[this.type].color === '#4CAF50') {
						ctx.moveTo(0, -towerTypes[this.type].size * 1.2);
						ctx.lineTo(towerTypes[this.type].size, towerTypes[this.type].size);
						ctx.lineTo(-towerTypes[this.type].size, towerTypes[this.type].size);
						ctx.closePath();
						ctx.fill();
						ctx.fillStyle = '#fff';
						ctx.beginPath();
						ctx.arc(0, 0, 6 + Math.sin(Date.now() / 200), 0, Math.PI * 2);
						ctx.fill();
					} else {
						ctx.arc(0, 0, towerTypes[this.type].size, 0, Math.PI * 2);
						ctx.fill();
						ctx.fillStyle = '#555';
						ctx.fillRect(0, -5, 20, 10);
					}
					ctx.restore();
					if (this.firing > 0) {
						ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
						ctx.lineWidth = 4;
						ctx.beginPath();
						ctx.arc(this.x, this.y, towerTypes[this.type].size + this.firing / 2, 0, Math.PI * 2);
						ctx.stroke();
					}
					ctx.fillStyle = '#00ffcc';
					ctx.font = '12px Orbitron';
					ctx.fillText(`Lv${this.level}`, this.x - 10, this.y + 5);
					if (this === selectedTower) {
						ctx.strokeStyle = '#00ffcc';
						ctx.lineWidth = 3;
						ctx.beginPath();
						ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
						ctx.stroke();
					}
				}
			}

			// Projectile class
			class Projectile {
				constructor(x, y, target, damage, color) {
					this.x = x;
					this.y = y;
					this.target = target;
					this.damage = damage;
					this.color = color;
					this.speed = 7;
					this.trail = [];
				}
				update() {
					if (!this.target || enemies.indexOf(this.target) === -1) {
						projectiles.splice(projectiles.indexOf(this), 1);
						return;
					}
					this.trail.push({ x: this.x, y: this.y, life: 10 });
					if (this.trail.length > 5) this.trail.shift();
					const dx = this.target.x - this.x;
					const dy = this.target.y - this.y;
					const distance = Math.sqrt(dx * dx + dy * dy);
					if (distance < this.speed) {
						projectiles.splice(projectiles.indexOf(this), 1);
					} else {
						this.x += (dx / distance) * this.speed;
						this.y += (dy / distance) * this.speed;
					}
				}
				draw() {
					ctx.globalAlpha = 0.5;
					ctx.fillStyle = this.color;
					this.trail.forEach((point, i) => {
						ctx.globalAlpha = (point.life / 10) * 0.5;
						ctx.beginPath();
						ctx.arc(point.x, point.y, 3 * (point.life / 10), 0, Math.PI * 2);
						ctx.fill();
						point.life--;
					});
					ctx.globalAlpha = 1;
					ctx.fillStyle = this.color;
					ctx.beginPath();
					if (this.color === '#2196F3') {
						ctx.rect(this.x - 6, this.y - 6, 12, 12);
					} else if (this.color === '#4CAF50') {
						ctx.arc(this.x, this.y, 5, 0, Math.PI * 2);
					} else {
						ctx.moveTo(this.x, this.y - 8);
						ctx.lineTo(this.x + 7, this.y + 5);
						ctx.lineTo(this.x - 7, this.y + 5);
						ctx.closePath();
					}
					ctx.fill();
					ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
					ctx.lineWidth = 1;
					ctx.stroke();
				}
			}

			// Update UI
			function updateUI() {
				scoreDisplay.textContent = `${score} (x${scoreMultiplier})`;
				moneyDisplay.textContent = money;
				healthDisplay.textContent = health;
				waveDisplay.textContent = wave;
				basicTowerBtn.classList.toggle('disabled', money < towerTypes.basic.cost);
				fastTowerBtn.classList.toggle('disabled', money < towerTypes.fast.cost);
				heavyTowerBtn.classList.toggle('disabled', money < towerTypes.heavy.cost);
				cancelBtn.classList.toggle('disabled', !placingTower);
				pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
				soundBtn.textContent = `Sound: ${soundEnabled ? 'On' : 'Off'}`;
				musicBtn.textContent = `Music: ${musicEnabled ? 'On' : 'Off'}`;
				startWaveBtn.classList.toggle('disabled', waveStarted);
				waveProgressBar.style.width = `${(1 - enemiesToSpawn / (5 + wave * 2 * currentMap.difficulty.enemies)) * 100}%`;
				waveTimerDisplay.textContent = waveStarted ? 'Wave in Progress' : `Next Wave: ${waveCountdown.toFixed(1)}s`;
				if (powerUp) {
					waveTimerDisplay.textContent += ` | ${powerUp.charAt(0).toUpperCase() + powerUp.slice(1)} Boost: ${(powerUpTimer / 60).toFixed(1)}s`;
				}
			}

			// Update tower popup
			function updatePopup() {
				if (selectedTower) {
					const upgradeCost = selectedTower.getUpgradeCost();
					popupInfo.textContent = `Type: ${selectedTower.type.charAt(0).toUpperCase() + selectedTower.type.slice(1)} (Lv${selectedTower.level})\nDamage: ${selectedTower.damage}\nRange: ${selectedTower.range}\nFire Rate: ${(60 / selectedTower.fireRate).toFixed(2)}/s\nTargeting: ${selectedTower.targeting.charAt(0).toUpperCase() + selectedTower.targeting.slice(1)}`;
					popupUpgradeBtn.textContent = `Upgrade ($${upgradeCost})`;
					popupSellBtn.textContent = `Sell ($${selectedTower.getSellValue()})`;
					popupUpgradeBtn.classList.toggle('disabled', selectedTower.level >= 3 || money < upgradeCost);
					targetClosestBtn.classList.toggle('active', selectedTower.targeting === 'closest');
					targetFarthestBtn.classList.toggle('active', selectedTower.targeting === 'farthest');
					targetMostHealthBtn.classList.toggle('active', selectedTower.targeting === 'mostHealth');
					targetLeastHealthBtn.classList.toggle('active', selectedTower.targeting === 'leastHealth');
					towerPopup.style.display = 'block';
					const rect = canvas.getBoundingClientRect();
					let popupX = selectedTower.x + rect.left + 20;
					let popupY = selectedTower.y + rect.top - 20;
					if (popupX + 200 > rect.right) popupX = selectedTower.x + rect.left - 220;
					if (popupY + 180 > rect.bottom) popupY = selectedTower.y + rect.top - 180;
					towerPopup.style.left = `${popupX}px`;
					towerPopup.style.top = `${popupY}px`;
				} else {
					towerPopup.style.display = 'none';
				}
			}

			// Spawn enemies
			let waveTimer = 0;
			let enemiesToSpawn = 0;
			function spawnWave() {
				if (!waveStarted || isPaused) return;
				if (enemiesToSpawn > 0 && waveTimer % 40 === 0) {
					const type = Math.floor(Math.random() * Math.min(Math.max(wave, 3), enemyTypes.length));
					enemies.push(new Enemy(type));
					enemiesToSpawn--;
				}
				if (enemiesToSpawn === 0 && enemies.length === 0) {
					waveStarted = false;
					waveCountdown = 10;
					scoreMultiplier = 1;
					consecutiveKills = 0;
					updateUI();
				}
				waveTimer++;
			}

			// Wave countdown
			let lastTime = performance.now();
			function updateWaveCountdown(timestamp) {
				if (!waveStarted && !isPaused && gameStarted && !gameOver) {
					const delta = (timestamp - lastTime) / 1000;
					waveCountdown = Math.max(0, waveCountdown - delta);
					if (waveCountdown <= 0 && !waveStarted) {
						wave++;
						enemiesToSpawn = Math.floor((5 + wave * 2) * currentMap.difficulty.enemies);
						waveStarted = true;
						waveTimer = 0;
					}
					updateUI();
				}
				if (powerUp) {
					powerUpTimer--;
					if (powerUpTimer <= 0) {
						powerUp = null;
					}
				}
				lastTime = timestamp;
			}

			// Draw path as squares
			function drawPath() {
				ctx.fillStyle = '#666';
				for (let i = 0; i < currentMap.path.length - 1; i++) {
					const p1 = currentMap.path[i];
					const p2 = currentMap.path[i + 1];
					const dx = p2.x - p1.x;
					const dy = p2.y - p1.y;
					const length = Math.sqrt(dx * dx + dy * dy);
					const steps = Math.ceil(length / GRID_SIZE);
					const stepX = dx / steps;
					const stepY = dy / steps;
					for (let j = 0; j <= steps; j++) {
						const x = p1.x + stepX * j;
						const y = p1.y + stepY * j;
						const snapped = snapToGrid(x, y);
						ctx.fillRect(snapped.x - GRID_SIZE / 2, snapped.y - GRID_SIZE / 2, GRID_SIZE, GRID_SIZE);
					}
				}
				ctx.strokeStyle = '#00ffcc';
				ctx.lineWidth = 2;
				ctx.beginPath();
				ctx.moveTo(currentMap.path[0].x, currentMap.path[0].y);
				for (let i = 1; i < currentMap.path.length; i++) {
					ctx.lineTo(currentMap.path[i].x, currentMap.path[i].y);
				}
				ctx.stroke();
			}

			// Draw grid
			function drawGrid() {
				ctx.strokeStyle = 'rgba(0, 255, 204, 0.2)';
				ctx.lineWidth = 1;
				for (let x = 0; x < canvas.width; x += GRID_SIZE) {
					ctx.beginPath();
					ctx.moveTo(x, 0);
					ctx.lineTo(x, canvas.height);
					ctx.stroke();
				}
				for (let y = 0; y < canvas.height; y += GRID_SIZE) {
					ctx.beginPath();
					ctx.moveTo(0, y);
					ctx.lineTo(canvas.width, y);
					ctx.stroke();
				}
			}

			// Snap to grid
			function snapToGrid(x, y) {
				return {
					x: Math.round(x / GRID_SIZE) * GRID_SIZE,
					y: Math.round(y / GRID_SIZE) * GRID_SIZE
				};
			}

			// Validate placement
			function isValidPlacement(x, y) {
				for (let i = 0; i < currentMap.path.length - 1; i++) {
					const p1 = currentMap.path[i];
					const p2 = currentMap.path[i + 1];
					const dx = p2.x - p1.x;
					const dy = p2.y - p1.y;
					const length = Math.sqrt(dx * dx + dy * dy);
					const steps = Math.ceil(length / GRID_SIZE);
					const stepX = dx / steps;
					const stepY = dy / steps;
					for (let j = 0; j <= steps; j++) {
						const px = p1.x + stepX * j;
						const py = p1.y + stepY * j;
						const snapped = snapToGrid(px, py);
						if (Math.abs(snapped.x - x) < GRID_SIZE / 2 && Math.abs(snapped.y - y) < GRID_SIZE / 2) {
							return false;
						}
					}
				}
				for (let tower of towers) {
					if (tower.x === x && tower.y === y) return false;
				}
				return true;
			}

			// Handle tower placement
			function startPlacingTower(type) {
				if (money >= towerTypes[type].cost) {
					placingTower = type;
					canvas.style.cursor = 'crosshair';
				}
			}

			basicTowerBtn.addEventListener('click', () => startPlacingTower('basic'));
			fastTowerBtn.addEventListener('click', () => startPlacingTower('fast'));
			heavyTowerBtn.addEventListener('click', () => startPlacingTower('heavy'));
			pauseBtn.addEventListener('click', () => {
				isPaused = !isPaused;
				updateUI();
			});
			soundBtn.addEventListener('click', () => {
				soundEnabled = !soundEnabled;
				updateUI();
			});
			musicBtn.addEventListener('click', () => {
				musicEnabled = !musicEnabled;
				if (musicEnabled) {
					backgroundMusic.play();
				} else {
					backgroundMusic.pause();
				}
				updateUI();
			});
			startWaveBtn.addEventListener('click', () => {
				if (!waveStarted) {
					wave++;
					enemiesToSpawn = Math.floor((5 + wave * 2) * currentMap.difficulty.enemies);
					waveStarted = true;
					waveTimer = 0;
					waveCountdown = 0;
					updateUI();
				}
			});
			cancelBtn.addEventListener('click', () => {
				placingTower = null;
				canvas.style.cursor = 'default';
				updateUI();
			});
			map1Btn.addEventListener('click', () => startGame('map1'));
			map2Btn.addEventListener('click', () => startGame('map2'));
			map3Btn.addEventListener('click', () => startGame('map3'));
			map4Btn.addEventListener('click', () => startGame('map4'));
			map5Btn.addEventListener('click', () => startGame('map5'));
			popupUpgradeBtn.addEventListener('click', () => {
				if (selectedTower) selectedTower.upgrade();
			});
			popupSellBtn.addEventListener('click', () => {
				if (selectedTower) selectedTower.sell();
			});
			targetClosestBtn.addEventListener('click', () => {
				if (selectedTower) selectedTower.setTargeting('closest');
			});
			targetFarthestBtn.addEventListener('click', () => {
				if (selectedTower) selectedTower.setTargeting('farthest');
			});
			targetMostHealthBtn.addEventListener('click', () => {
				if (selectedTower) selectedTower.setTargeting('mostHealth');
			});
			targetLeastHealthBtn.addEventListener('click', () => {
				if (selectedTower) selectedTower.setTargeting('leastHealth');
			});

			function startGame(mapKey) {
				currentMap = maps[mapKey];
				money = currentMap.difficulty.money;
				score = 0;
				health = 100;
				wave = 0;
				enemies = [];
				towers = [];
				projectiles = [];
				particles = [];
				damageTexts = [];
				gameOver = false;
				isPaused = false;
				waveStarted = false;
				waveCountdown = 10;
				scoreMultiplier = 1;
				consecutiveKills = 0;
				powerUp = null;
				powerUpTimer = 0;
				gameStarted = true;
				for (let i = 0; i < 20; i++) {
					particles.push(new Particle(Math.random() * canvas.width, canvas.height + Math.random() * 100, '#00ffcc', 'background'));
				}
				titleScreen.style.opacity = '0';
				setTimeout(() => {
					titleScreen.style.display = 'none';
					document.getElementById('ui').style.display = 'flex';
					updateUI();
				}, 800);
				if (musicEnabled) backgroundMusic.play();
			}

			canvas.addEventListener('click', (e) => {
				if (!gameStarted || isPaused) return;
				const rect = canvas.getBoundingClientRect();
				const { x, y } = snapToGrid(e.clientX - rect.left, e.clientY - rect.top);

				if (!placingTower) {
					selectedTower = null;
					for (let tower of towers) {
						if (Math.hypot(x - tower.x, y - tower.y) < towerTypes[tower.type].size) {
							selectedTower = tower;
							break;
						}
					}
					updatePopup();
					return;
				}

				if (placingTower && money >= towerTypes[placingTower].cost) {
					if (isValidPlacement(x, y)) {
						towers.push(new Tower(x, y, placingTower));
						money -= towerTypes[placingTower].cost;
						placingTower = null;
						canvas.style.cursor = 'default';
						updateUI();
					}
				}
			});

			canvas.addEventListener('contextmenu', (e) => {
				e.preventDefault();
				if (placingTower) {
					placingTower = null;
					canvas.style.cursor = 'default';
					updateUI();
				}
			});

			let mouseX = 0, mouseY = 0;
			canvas.addEventListener('mousemove', (e) => {
				if (placingTower) {
					const rect = canvas.getBoundingClientRect();
					const snapped = snapToGrid(e.clientX - rect.left, e.clientY - rect.top);
					mouseX = snapped.x;
					mouseY = snapped.y;
				}
			});

			document.addEventListener('click', (e) => {
				if (selectedTower && !canvas.contains(e.target) && !towerPopup.contains(e.target)) {
					selectedTower = null;
					towerPopup.style.display = 'none';
				}
			});

			// Game loop
			function gameLoop(timestamp) {
				if (!gameStarted) {
					ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
					ctx.fillRect(0, 0, canvas.width, canvas.height);
					for (let particle of particles) {
						particle.update();
						particle.draw();
					}
					animationFrameId = requestAnimationFrame(gameLoop);
					return;
				}
				if (gameOver) {
					ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
					ctx.fillRect(0, 0, canvas.width, canvas.height);
					ctx.fillStyle = '#00ffcc';
					ctx.font = '48px Orbitron';
					ctx.textAlign = 'center';
					ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 50);
					ctx.font = '24px Orbitron';
					ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2);
					ctx.fillText(`High Score: ${highScore}`, canvas.width / 2, canvas.height / 2 + 50);
					ctx.fillText('Click to Restart', canvas.width / 2, canvas.height / 2 + 100);
					canvas.addEventListener('click', restartGame, { once: true });
					return;
				}
				if (isPaused) {
					ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
					ctx.fillRect(0, 0, canvas.width, canvas.height);
					ctx.fillStyle = '#00ffcc';
					ctx.font = '48px Orbitron';
					ctx.textAlign = 'center';
					ctx.fillText('Paused', canvas.width / 2, canvas.height / 2);
					animationFrameId = requestAnimationFrame(gameLoop);
					return;
				}

				updateWaveCountdown(timestamp);
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				drawGrid();
				drawPath();
				spawnWave();

				for (let particle of particles) {
					particle.update();
					particle.draw();
				}
				for (let enemy of enemies) {
					enemy.update();
					enemy.draw();
				}
				for (let tower of towers) {
					tower.update();
					tower.draw();
				}
				for (let projectile of projectiles) {
					projectile.update();
					projectile.draw();
				}
				for (let text of damageTexts) {
					text.update();
					text.draw();
				}

				if (placingTower) {
					const isValid = isValidPlacement(mouseX, mouseY);
					ctx.fillStyle = isValid ? 'rgba(0, 255, 204, 0.3)' : 'rgba(255, 68, 68, 0.3)';
					ctx.fillRect(mouseX - GRID_SIZE / 2, mouseY - GRID_SIZE / 2, GRID_SIZE, GRID_SIZE);
					ctx.fillStyle = towerTypes[placingTower].color;
					ctx.globalAlpha = 0.7;
					ctx.save();
					ctx.translate(mouseX, mouseY);
					ctx.beginPath();
					if (placingTower === 'basic') {
						ctx.rect(-towerTypes[placingTower].size, -towerTypes[placingTower].size, towerTypes[placingTower].size * 2, towerTypes[placingTower].size * 2);
						ctx.fill();
						ctx.fillStyle = '#555';
						ctx.fillRect(-5, -towerTypes[placingTower].size - 10, 10, 15);
					} else if (placingTower === 'fast') {
						ctx.moveTo(0, -towerTypes[placingTower].size * 1.2);
						ctx.lineTo(towerTypes[placingTower].size, towerTypes[placingTower].size);
						ctx.lineTo(-towerTypes[placingTower].size, towerTypes[placingTower].size);
						ctx.closePath();
						ctx.fill();
						ctx.fillStyle = '#fff';
						ctx.beginPath();
						ctx.arc(0, 0, 6, 0, Math.PI * 2);
						ctx.fill();
					} else {
						ctx.arc(0, 0, towerTypes[placingTower].size, 0, Math.PI * 2);
						ctx.fill();
						ctx.fillStyle = '#555';
						ctx.fillRect(0, -5, 20, 10);
					}
					ctx.restore();
					ctx.strokeStyle = isValid ? '#00ffcc' : '#ff4444';
					ctx.lineWidth = 3;
					ctx.beginPath();
					ctx.arc(mouseX, mouseY, towerTypes[placingTower].range, 0, Math.PI * 2);
					ctx.stroke();
					ctx.globalAlpha = 1;
				}

				if (powerUp) {
					ctx.fillStyle = powerUp === 'damage' ? '#ff4081' : '#00ffcc';
					ctx.font = '16px Orbitron';
					ctx.fillText(`${powerUp.charAt(0).toUpperCase() + powerUp.slice(1)} Boost!`, 20, 30);
				}

				animationFrameId = requestAnimationFrame(gameLoop);
			}

			function restartGame() {
				cancelAnimationFrame(animationFrameId);
				if (score > highScore) {
					highScore = score;
					localStorage.setItem('towerDefenseHighScore', highScore);
				}
				score = 0;
				money = currentMap.difficulty.money;
				health = 100;
				wave = 0;
				enemies = [];
				towers = [];
				projectiles = [];
				particles = [];
				damageTexts = [];
				gameOver = false;
				isPaused = false;
				waveStarted = false;
				waveCountdown = 10;
				scoreMultiplier = 1;
				consecutiveKills = 0;
				powerUp = null;
				powerUpTimer = 0;
				gameStarted = false;
				selectedTower = null;
				towerPopup.style.display = 'none';
				titleScreen.style.display = 'flex';
				titleScreen.style.opacity = '1';
				document.getElementById('ui').style.display = 'none';
				for (let i = 0; i < 20; i++) {
					particles.push(new Particle(Math.random() * canvas.width, canvas.height + Math.random() * 100, '#00ffcc', 'background'));
				}
				if (musicEnabled) backgroundMusic.play();
				updateUI();
				gameLoop();
			}

			// Initialize background particles
			for (let i = 0; i < 20; i++) {
				particles.push(new Particle(Math.random() * canvas.width, canvas.height + Math.random() * 100, '#00ffcc', 'background'));
			}

			// Start game loop
			gameLoop(performance.now());
		</script>
	</body>

</html>